package epiweb.server.epidb ;

import java.util.Map ;
import java.util.HashMap ;
import java.sql.Connection ;
import java.sql.SQLException ;
import com.javaranch.common.Str ;
import com.javaranch.db.DBResults ;
import com.javaranch.db.TableFacade ;

/** Strongly typed access to the database table "study_design".
 *
 * This source file was automatically generated by "Jenny the db code generator"
 * based on information found in the database.  Do not modify this file!
 *
 * For more information on Jenny, see http://www.javaranch.com/jenny.jsp
 *
 *
 * Most of the methods are static so you don't need to instantiate a copy of this class 
 * to do your work.  The primary access methods are:
 * <ul>
 *
 *     <b>getRow()/getRows()/getAllRows()</b><br>
 *     <b>search() </b><i>like getRows(), but you can specify which columns you want back</i><br>
 *     <b>update()</b><br>
 *     <b>delete()</b><br>
 *     <b>insert()</b><br>
 *
 * </ul>
 *
 * These methods all have the option of passing in a connection as the first parameter.
 * Usually you won't use a connection directly, but sometimes it's useful.
 *
 * The getRows() methods all return an array of Row objects or a single Row object.  The
 * row object is easy to work with and provides strong type checking.  If your table has
 * a lot of columns, and your search will return a lot of rows, you might want to consider
 * using a search() method instead.  You lose some of your strong type checking, but 
 * you might go a lot easier on memory.  In these cases, you will want to make sure you
 * use the column name constants found at the top of this class.
 *
 */
public class Study_designTable
{

    private static Implementation imp = new Implementation();

    public static final String tableName = "study_design";

    public static final String pmidColumnName = "pmid";
    public static final String yearColumnName = "year";
    public static final String type_of_studyColumnName = "type_of_study";
    public static final String others_study_designColumnName = "others_study_design";
    public static final String clinicalColumnName = "clinical";
    public static final String blindedColumnName = "blinded";
    public static final String treatment_responseColumnName = "treatment_response";
    public static final String armColumnName = "arm";
    public static final String type_of_randomizationColumnName = "type_of_randomization";
    public static final String sponsoredColumnName = "sponsored";
    public static final String phaseColumnName = "phase";
    public static final String synthesis_of_evidenceColumnName = "synthesis_of_evidence";
    public static final String type_of_reviewColumnName = "type_of_review";
    public static final String case_control_typeColumnName = "case_control_type";
    public static final String quasi_experimental_typeColumnName = "quasi_experimental_type";
    public static final String time_attributeColumnName = "time_attribute";
    public static final String cohort_typeColumnName = "cohort_type";
    public static final String occupationalColumnName = "occupational";
    public static final String is_it_serialColumnName = "is_it_serial";

    private static String[] allColumns =
    {
        pmidColumnName , yearColumnName , type_of_studyColumnName , others_study_designColumnName , clinicalColumnName , blindedColumnName , treatment_responseColumnName , armColumnName , type_of_randomizationColumnName , sponsoredColumnName , phaseColumnName , synthesis_of_evidenceColumnName , type_of_reviewColumnName , case_control_typeColumnName , quasi_experimental_typeColumnName , time_attributeColumnName , cohort_typeColumnName , occupationalColumnName , is_it_serialColumnName , 
    };

    /** You probably want to use the static methods for most of your access, but once in a while you might need to
     *  pass an instance object to a method that knows how to work with these sorts of tables.
     */
    public static Implementation getInstance()
    {
        return imp ;
    }

    /** For use by unit testing, although you could provide your own implementation here if
     *  you wanted to.
     *  
     *  To use this in your unit testing, create an instance of MockStudy_designTable and pass
     *  it in here.  Then set your mock return values, call the method you are testing and examine
     *  the mock values that are now set!
     */
    public static void setInstance( Study_designTable.Implementation instance  )
    {
        imp = instance ;
    }

    /** Exposed for unit testing purposes only! */
    static class Implementation extends TableFacade
    {

        /** Exposed for unit testing purposes only! */
        Implementation()
        {
            super( EpidbFacade.getInstance() , tableName );
        }

        // convert a DBResults object to an array of Row objects.
        // requires that all of the columns be represented in the DBResults object and in the right order
        private static Row[] rowArray( DBResults r )
        {
            Row[] rows = new Row[ r.size() ];
            for( int i = 0 ; i < rows.length ; i++ )
            {
                rows[ i ] = new Row( r.getRow( i ) );
            }
            return rows ;
        }

        /** Instantiate an empty Row object */
        public Row getRow()
        {
            // if you are wondering about why this method is so lame - it's for unit testing!
            // The idea is that during unit testing, a different test object will be returned here.
            // To learn more about unit testing with Jenny generated code, visit <a href="http://www.javaranch.com/jenny.jsp">www.javaranch.com/jenny.jsp</a>
            return new Row();
        }

        /** Instantiate a Row object and fill its content based on a search
         *
         * Return null if not found.
         */
        public Row getRow( Connection con , String column , String searchText ) throws SQLException
        {
            Row row = new Row( this.search( con , column , searchText , allColumns ) );
            return row.dataLoadedFromDatabase() ? row : null ;
        }

        /** Instantiate a Row object and fill its content based on a search
         *
         * Return null if not found.
         */
        public Row getRow( String column , String searchText ) throws SQLException
        {
            Row row = new Row( this.search( column , searchText , allColumns ) );
            return row.dataLoadedFromDatabase() ? row : null ;
        }

        /** Return an array of length zero if nothing found */
        public Row[] getRows( Connection con , String column , String searchText ) throws SQLException
        {
            return rowArray( this.search( con , column , searchText , allColumns ) );
        }

        /** Return an array of length zero if nothing found */
        public Row[] getRows( String column , String searchText ) throws SQLException
        {
            return rowArray( this.search( column , searchText , allColumns ) );
        }

        /** Return an array of length zero if nothing found */
        public Row[] getRows( Connection con , String column , String[] searchText ) throws SQLException
        {
            return rowArray( this.search( con , column , searchText , allColumns ) );
        }

        /** Return an array of length zero if nothing found */
        public Row[] getRows( String column , String[] searchText ) throws SQLException
        {
            return rowArray( this.search( column , searchText , allColumns ) );
        }

        /** Return an array of length zero if nothing found */
        public Row[] getRows( Connection con , String whereClause ) throws SQLException
        {
            return rowArray( this.search( con , whereClause , allColumns ) );
        }

        /** Return an array of length zero if nothing found */
        public Row[] getRows( String whereClause ) throws SQLException
        {
            return rowArray( this.search( whereClause , allColumns ) );
        }

        /** Return an array of length zero if nothing found */
        public Row[] getAllRows( Connection con ) throws SQLException
        {
            return rowArray( this.search( con , allColumns ) );
        }

        /** Return an array of length zero if nothing found */
        public Row[] getAllRows() throws SQLException
        {
            return rowArray( this.search( allColumns ) );
        }


    }

    public static class Row
    {

        private boolean dataLoadedFromDatabase = false ;

        private int pmid ;
        private boolean pmidNull = true ;
        private int year ;
        private boolean yearNull = true ;
        private String type_of_study ;
        private String others_study_design ;
        private String clinical ;
        private String blinded ;
        private String treatment_response ;
        private String arm ;
        private String type_of_randomization ;
        private String sponsored ;
        private String phase ;
        private String synthesis_of_evidence ;
        private String type_of_review ;
        private String case_control_type ;
        private String quasi_experimental_type ;
        private String time_attribute ;
        private String cohort_type ;
        private String occupational ;
        private String is_it_serial ;

        /** for internal use only!   If you need a row object, use getRow(). */
        Row()
        {
        }

        private Row( String[] data )
        {
            if ( data != null )
            {
                this.pmidNull = ( data[0] == null );
                this.pmid = pmidNull ? 0 : Str.toInt( data[0] );
                this.yearNull = ( data[1] == null );
                this.year = yearNull ? 0 : Str.toInt( data[1] );
                this.type_of_study = data[2];
                this.others_study_design = data[3];
                this.clinical = data[4];
                this.blinded = data[5];
                this.treatment_response = data[6];
                this.arm = data[7];
                this.type_of_randomization = data[8];
                this.sponsored = data[9];
                this.phase = data[10];
                this.synthesis_of_evidence = data[11];
                this.type_of_review = data[12];
                this.case_control_type = data[13];
                this.quasi_experimental_type = data[14];
                this.time_attribute = data[15];
                this.cohort_type = data[16];
                this.occupational = data[17];
                this.is_it_serial = data[18];
                dataLoadedFromDatabase = true ;
            }
        }

        private Row( DBResults results )
        {
            this( results.getRow(0) );
        }

        public int getPmid()
        {
            return pmid ;
        }

        public void setPmid( int pmid )
        {
            this.pmid = pmid ;
            pmidNull = false ;
        }

        public void setPmid( Integer pmid )
        {
            pmidNull = ( pmid == null );
            if ( pmidNull )
            {
                this.pmid = 0 ;
            }
            else
            {
                this.pmid = pmid.intValue() ;
            }
        }

        public boolean isPmidNull()
        {
            return pmidNull ;
        }

        public void setPmidNull( boolean pmidNull )
        {
            this.pmidNull = pmidNull ;
            if ( pmidNull )
            {
                pmid = 0 ;
            }
        }


        public int getYear()
        {
            return year ;
        }

        public void setYear( int year )
        {
            this.year = year ;
            yearNull = false ;
        }

        public void setYear( Integer year )
        {
            yearNull = ( year == null );
            if ( yearNull )
            {
                this.year = 0 ;
            }
            else
            {
                this.year = year.intValue() ;
            }
        }

        public boolean isYearNull()
        {
            return yearNull ;
        }

        public void setYearNull( boolean yearNull )
        {
            this.yearNull = yearNull ;
            if ( yearNull )
            {
                year = 0 ;
            }
        }


        public String getType_of_study()
        {
            return type_of_study ;
        }

        public void setType_of_study( String type_of_study )
        {
            this.type_of_study = type_of_study ;
        }


        public String getOthers_study_design()
        {
            return others_study_design ;
        }

        public void setOthers_study_design( String others_study_design )
        {
            this.others_study_design = others_study_design ;
        }


        public String getClinical()
        {
            return clinical ;
        }

        public void setClinical( String clinical )
        {
            this.clinical = clinical ;
        }


        public String getBlinded()
        {
            return blinded ;
        }

        public void setBlinded( String blinded )
        {
            this.blinded = blinded ;
        }


        public String getTreatment_response()
        {
            return treatment_response ;
        }

        public void setTreatment_response( String treatment_response )
        {
            this.treatment_response = treatment_response ;
        }


        public String getArm()
        {
            return arm ;
        }

        public void setArm( String arm )
        {
            this.arm = arm ;
        }


        public String getType_of_randomization()
        {
            return type_of_randomization ;
        }

        public void setType_of_randomization( String type_of_randomization )
        {
            this.type_of_randomization = type_of_randomization ;
        }


        public String getSponsored()
        {
            return sponsored ;
        }

        public void setSponsored( String sponsored )
        {
            this.sponsored = sponsored ;
        }


        public String getPhase()
        {
            return phase ;
        }

        public void setPhase( String phase )
        {
            this.phase = phase ;
        }


        public String getSynthesis_of_evidence()
        {
            return synthesis_of_evidence ;
        }

        public void setSynthesis_of_evidence( String synthesis_of_evidence )
        {
            this.synthesis_of_evidence = synthesis_of_evidence ;
        }


        public String getType_of_review()
        {
            return type_of_review ;
        }

        public void setType_of_review( String type_of_review )
        {
            this.type_of_review = type_of_review ;
        }


        public String getCase_control_type()
        {
            return case_control_type ;
        }

        public void setCase_control_type( String case_control_type )
        {
            this.case_control_type = case_control_type ;
        }


        public String getQuasi_experimental_type()
        {
            return quasi_experimental_type ;
        }

        public void setQuasi_experimental_type( String quasi_experimental_type )
        {
            this.quasi_experimental_type = quasi_experimental_type ;
        }


        public String getTime_attribute()
        {
            return time_attribute ;
        }

        public void setTime_attribute( String time_attribute )
        {
            this.time_attribute = time_attribute ;
        }


        public String getCohort_type()
        {
            return cohort_type ;
        }

        public void setCohort_type( String cohort_type )
        {
            this.cohort_type = cohort_type ;
        }


        public String getOccupational()
        {
            return occupational ;
        }

        public void setOccupational( String occupational )
        {
            this.occupational = occupational ;
        }


        public String getIs_it_serial()
        {
            return is_it_serial ;
        }

        public void setIs_it_serial( String is_it_serial )
        {
            this.is_it_serial = is_it_serial ;
        }



        
        private boolean dataLoadedFromDatabase()
        {
            return dataLoadedFromDatabase ;
        }

        private Map buildDataMap()
        {
            Map data = new HashMap();
            data.put( pmidColumnName , this.pmidNull ? null : String.valueOf( this.pmid ) );
            data.put( yearColumnName , this.yearNull ? null : String.valueOf( this.year ) );
            data.put( type_of_studyColumnName , this.type_of_study );
            data.put( others_study_designColumnName , this.others_study_design );
            data.put( clinicalColumnName , this.clinical );
            data.put( blindedColumnName , this.blinded );
            data.put( treatment_responseColumnName , this.treatment_response );
            data.put( armColumnName , this.arm );
            data.put( type_of_randomizationColumnName , this.type_of_randomization );
            data.put( sponsoredColumnName , this.sponsored );
            data.put( phaseColumnName , this.phase );
            data.put( synthesis_of_evidenceColumnName , this.synthesis_of_evidence );
            data.put( type_of_reviewColumnName , this.type_of_review );
            data.put( case_control_typeColumnName , this.case_control_type );
            data.put( quasi_experimental_typeColumnName , this.quasi_experimental_type );
            data.put( time_attributeColumnName , this.time_attribute );
            data.put( cohort_typeColumnName , this.cohort_type );
            data.put( occupationalColumnName , this.occupational );
            data.put( is_it_serialColumnName , this.is_it_serial );
            return data ;
        }

        /** update a row object based on a search */
        public void update( Connection con , String column , String searchText ) throws SQLException
        {
            imp.update( con , column , searchText , buildDataMap() );
        }

        /** update a row object based on a search */
        public void update( String column , String searchText ) throws SQLException
        {
            imp.update( column , searchText , buildDataMap() );
        }

        /** create a new row.*/
        public void insert( Connection con ) throws SQLException
        {
            imp.insert( con , buildDataMap() );
        }

        /** create a new row.*/
        public void insert() throws SQLException
        {
            imp.insert( buildDataMap() );
        }


    }

    /** Return an empty row object */
    public static Row getRow()
    {
        return imp.getRow();
    }

    /** Instantiate a Row object and fill its content based on a search
     *
     * Return null if not found.
     */
    public static Row getRow( Connection con , String column , String searchText ) throws SQLException
    {
        return imp.getRow( con , column , searchText );
    }

    /** Instantiate a Row object and fill its content based on a search
     *
     * Return null if not found.
     */
    public static Row getRow( String column , String searchText ) throws SQLException
    {
        return imp.getRow( column , searchText );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( Connection con , String column , String searchText ) throws SQLException
    {
        return imp.getRows( con , column , searchText );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( String column , String searchText ) throws SQLException
    {
        return imp.getRows( column , searchText );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( Connection con , String column , String[] searchText ) throws SQLException
    {
        return imp.getRows( con , column , searchText );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( String column , String[] searchText ) throws SQLException
    {
        return imp.getRows( column , searchText );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( Connection con , String column , int searchValue ) throws SQLException
    {
        return imp.getRows( con , column , String.valueOf( searchValue ) );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( String column , int searchValue ) throws SQLException
    {
        return imp.getRows( column , String.valueOf( searchValue ) );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( Connection con , String column , int[] searchValues ) throws SQLException
    {
        return imp.getRows( con , column , Str.toStringArray( searchValues ) );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( String column , int[] searchValues ) throws SQLException
    {
        return imp.getRows( column , Str.toStringArray( searchValues ) );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( Connection con , String whereClause ) throws SQLException
    {
        return imp.getRows( con , whereClause );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getRows( String whereClause ) throws SQLException
    {
        return imp.getRows( whereClause );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getAllRows( Connection con ) throws SQLException
    {
        return imp.getAllRows( con );
    }

    /** Return an array of length zero if nothing found */
    public static Row[] getAllRows() throws SQLException
    {
        return imp.getAllRows();
    }

    public static DBResults search( Connection con , String column , String searchText , String[] dataColumns ) throws SQLException
    {
        return imp.search( con , column , searchText , dataColumns );
    }

    public static DBResults search( String column , String searchText , String[] dataColumns ) throws SQLException
    {
        return imp.search( column , searchText , dataColumns );
    }

    public static DBResults search( Connection con , String column , String[] searchText , String[] dataColumns ) throws SQLException
    {
        return imp.search( con , column , searchText , dataColumns );
    }

    public static DBResults search( String column , String searchText[] , String[] dataColumns ) throws SQLException
    {
        return imp.search( column , searchText , dataColumns );
    }

    public static DBResults search( Connection con , String column , int searchValue , String[] dataColumns ) throws SQLException
    {
        return imp.search( con , column , searchValue , dataColumns );
    }

    public static DBResults search( String column , int searchValue , String[] dataColumns ) throws SQLException
    {
        return imp.search( column , searchValue , dataColumns );
    }

    public static DBResults search( Connection con , String column , int[] searchValues , String[] dataColumns ) throws SQLException
    {
        return imp.search( con , column , searchValues , dataColumns );
    }

    public static DBResults search( String column , int[] searchValues , String[] dataColumns ) throws SQLException
    {
        return imp.search( column , searchValues , dataColumns );
    }

    public static DBResults search( Connection con , String whereClause , String[] dataColumns ) throws SQLException
    {
        return imp.search( con , whereClause , dataColumns );
    }

    public static DBResults search( String whereClause , String[] dataColumns ) throws SQLException
    {
        return imp.search( whereClause , dataColumns );
    }

    public static DBResults search( Connection con , String[] dataColumns ) throws SQLException
    {
        return imp.search( con , dataColumns );
    }

    public static DBResults search( String[] dataColumns ) throws SQLException
    {
        return imp.search( dataColumns );
    }

    public static void update( Connection con , String column , String searchText , Map data ) throws SQLException
    {
        imp.update( con , column , searchText , data );
    }

    public static void update( String column , String searchText , Map data ) throws SQLException
    {
        imp.update( column , searchText , data );
    }

    public static void delete( Connection con , String column , String searchText ) throws SQLException
    {
        imp.delete( con , column , searchText );
    }

    public static void delete( String column , String searchText ) throws SQLException
    {
        imp.delete( column , searchText );
    }

    public static void insert( Connection con , Map data ) throws SQLException
    {
        imp.insert( con , data );
    }

    public static void insert( Map data ) throws SQLException
    {
        imp.insert( data );
    }



}
